# 王者组-取石子游戏

来源：POJ - 1067

地址：https://vjudge.net/problem/POJ-1067

## 思路：

先思考必胜的状态

当出现下面的情况时，胜

1. **a = b**
2. **a = 0 or b = 0**

当出现下面的情况时，败

3. **a = 1, b = 2**

当出现下面的情况时，可以使对手处于**3**的情况，胜

4. **a = 1, b = n, n > 2**

5. **a - b = 1**

6. **a = 2 or b = 2**

当出现下面情况时，无论怎么选，败

7. **a = 3, b = 5**

通过这个规律，我们可以找到必败的点

> (1, 2) (3, 5) (4, 7) ...

寻找方法为：**对于第n组，小的数字为前面所有数字中没出现的最小正整数，大的数字为小的数字加n**

### 思路一：

通过循环列出所有的可能的点，但是因为范围太大，无法初始化这么大的一个数组

并且列出所有点的方法比较耗时

## 思路二：

因为上面的方法行不通，就只能通过找规律，找出 **n** 项的**直接表达式**或**递推式**

基础不足，在我知道了正确的解法后明白我是不可能想出来的

## 思路三：

这是一个不需要找规律的思路，用穷举（显然会超时）

取到最终是上面的 **1** 或 **2** 两种情况，我们可以写递归

```cpp
bool solve(int a, int b) {
    if (a == 0 || b == 0 || a == b) return ture;
    else return !(solve(a - 1, b) || solve(a, b - 1) || solve(a - 1, b - 1));
}
```

当然上面的这个思路可能是错的，因为超时了，我就没有去探究它的正确性

而且想用记忆化搜索，也因为数据太大无法实现

## 正确思路：

来源：http://www.matrix67.com/blog/archives/6784

对于上面的必败点的规律是：

> ([1 · φ], [1 · φ2]), ([2 · φ], [2 · φ2]), ([3 · φ], [3 · φ2]), ([4 · φ], [4 · φ2]), …

> 其中 φ = (√5 + 1) / 2 ， [x] 表示不超过 x 的最大整数

证明过程在上面的博客里有写

根据之前找到的规律，可以得到第 **n** 项的公式：

> a = (int)(n * (sqrt(5) + 1) / 2); b = a + n;

## 代码：
```cpp
//#include <bits/stdc++.h> poj居然到现在还不支持这个。。。
#include <cstdio>
#include <cmath>
#include <algorithm>
using namespace std;
const int max_n = 1e3 + 1;

int main() {
    printf("%d\n", 1);
    int a, b;
    double phi = (sqrt(5) + 1) / 2;
    while (~scanf("%d%d", &a, &b)) {
        if (a == 0 || b == 0 || a == b) {
            printf("1\n");
        } else {
            if (a > b) swap(a, b);
            int n = b - a;
            if ((int)(phi * n) == a) printf("0\n");
            else printf("1\n");
        }
    }
    return 0;
}
```